# Play-with-Algorithms

## 究竟什么是大O（Big O）

n表示数据规模

O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比

* 二分查找法O(logn)                
  * 所需执行指令数：a*logn
* 寻找数组中的最大/最小值O(n)        
  * 所需执行指令数：b*n
* 归并排序算法O(nlogn)             
  * 所需执行指令数：c*nlogn
* 选择排序法O(n^2)
  * 所需执行数：d*n^2

算法效率的改变和a、b、c、d的关系不大，而跟logn、n、nlogn、n^2密切相关

### 到底什么是Big O

>时间复杂度低的算法一定比时间复杂度高的算法快

执行这个算法前面就可能对应一个常数

* 算法A: O(n)
  * 所需执行指令数：10000*n
* 算法B：O(n^2)
  * 所需执行指令数：10*n^2

时间复杂度Big O，主要衡量的是量级上面的差距

研究算法主要就是为了处理大量的数据，因为数据非常小的话，时间总是够用的

在学术界，严格的讲，O(f(n))表示算法执行的上界

归并排序算法的时间复杂度是O(nlogn)的，同时也是O(n^2)

O( nlogn + n) = O( nlogn )

O( nlogn + n^2 ) = O( n^2 )

对邻接表实现的图进行遍历

时间复杂度：O( V+E )

>关于时间复杂度的问题

```bash
有一个字符串数组，将数组中的每一个字符串按照字母序排序，之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？
```

假设最长的字符串长度为s；数组中有n个字符串

对每个字符串排序：O(slogs)

将数组中的每一个字符串按照字母序排序：O(n*slog(s))

将整个字符串数组按照字典序排序：O(s*nlog(n))

## 数据规模的概念

对10^5的数据进行选择排序，结果计算机假死？

## 堆

### 普通队列

```bash
先进先出，后进后出
```

### 优先队列

```bash
出队顺序和入队顺序无关；和优先级相关

动态选择优先级最高的任务执行

关键词：动态

在1000000个元素中选出前100名

在N个元素中选出前M个元素
```

### 主要操作

```bash
入队
出队(取出优先级最高的元素)
```

![All text](http://ww1.sinaimg.cn/large/dc05ba18gy1fmmdifyxg5j21ty0s0jwp.jpg)

### 使用堆实现优先队列

```bash
对于总共N个请求

使用普通数组或者顺序数组，最差情况：O(n^2)

使用堆：O(nlgn)
```

### 堆的基本储存

```bash
堆一定相应的是一个树形结构

二叉树：任何一定节点都不大于它的父级节点
```

```bash
二叉堆是一个完全二叉树

堆中某个节点的值总是不大于其父节点的值

堆总是一颗完全二叉树（最大堆）
```
