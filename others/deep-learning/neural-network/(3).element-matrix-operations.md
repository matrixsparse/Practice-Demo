# matrix operations

```bash
如果你将所有的数字存储在一个矩阵中
你可以对它们执行元素级操作
这意味着你要在矩阵中分别处理它们，然后对每个元素执行同样的操作

矩阵这一元素级概念，适用于具有任意维数的数据，要加上两个标量的话，很简单，就像2+3=5
```

![All text](http://ww1.sinaimg.cn/large/dc05ba18gy1flpte4mayij20g7086t9h.jpg)

```bash
有一个值矩阵，代表图像的红色通道
每个值是单个字节，范围从0到255
要归一化这些值，并将它们转化为浮点值
范围从0到1，只需将此矩阵在元素级别除以255
```

![All text](http://ww1.sinaimg.cn/large/dc05ba18gy1flptevdbd1j20he08y795.jpg)

## 元素级运算

### python中的方式

假设你有一个数字列表，你想向列表中的每一项加上 5 。如果没有 NumPy，你可以像下面这样做：

```bash
values = [1,2,3,4,5]
for i in range(len(values)):
    values[i] += 5

# 现在的 values 为 [6,7,8,9,10]
```

### numpy中的方式

```bash
values = [1,2,3,4,5]
values = np.array(values) + 5

# 现在 values 是包含 [6,7,8,9,10] 的一个 ndarray
```

```bash
创建该数组可能看起来很奇怪，但通常你总是要将数据存储在 ndarray 中的。
所以如果你已经有一个名为 values 的 ndarray，你可以这么做：
```

```bash
values += 5
```

NumPy实际上有用于加法、乘法等运算的函数，但它也支持使用标准的数学运算符。所以以下两行是等价的：

```bash
x = np.multiply(some_array, 5)
x = some_array * 5
```

通常会使用运算符而不是函数，因为它们更方便键入，也更容易阅读，不过这只是个人偏好。

假设你有一个矩阵 m 并且你想复用它，但首先你需要将其所有值设为零。这很简单，只需给它乘以零，并将结果赋值回原矩阵就行了，如下所示：

```bash
m *= 0

# 现在 m 中的每个元素都是 0，无论它有多少维度
```

### 元素级矩阵运算

```bash
与标量和矩阵一起使用的相同函数和运算符也适用于其他维度。你只需要确保执行运算的项目具有兼容的形状。

假设你想得到矩阵的平方值。方法是 x = m * m（或者如果你要将值赋值回 m，则是 m *= m）

这是可行的，因为它是两个形状相同的矩阵之间的元素乘法。（在这个例子中，它们的形状相同，是因为它们实际上是同一个对象。）
```

```bash
a = np.array([[1,3],[5,7]])
a
# 显示以下结果：
# array([[1, 3],
#        [5, 7]])

b = np.array([[2,4],[6,8]])
b
# 显示以下结果：
# array([[2, 4],
#        [6, 8]])

a + b
# 显示以下结果：
#      array([[ 3,  7],
#             [11, 15]])
```

>使用不兼容的情况

```bash
a = np.array([[1,3],[5,7]])
a
# 显示以下结果：
# array([[1, 3],
#        [5, 7]])
c = np.array([[2,3,6],[4,5,9],[1,8,7]])
c
# 显示以下结果：
# array([[2, 3, 6],
#        [4, 5, 9],
#        [1, 8, 7]])

a.shape
# 显示以下结果：
#  (2, 2)

c.shape
# 显示以下结果：
#  (3, 3)

a + c
# 显示以下结果：
# ValueError: operands could not be broadcast together with shapes (2,2) (3,3)
```